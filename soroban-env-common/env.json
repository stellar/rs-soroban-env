{
    "modules": [
        {
            "name": "context",
            "export": "x",
            "functions": [
                {
                    "export": "_",
                    "name": "log_from_linear_memory",
                    "args": [
                        {
                            "name": "msg_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "msg_len",
                            "type": "U32Val"
                        },
                        {
                            "name": "vals_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "vals_len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Emit a diagnostic event containing a message and sequence of `Val`s."
                },
                {
                    "export": "0",
                    "name": "obj_cmp",
                    "args": [
                        {
                            "name": "a",
                            "type": "Val"
                        },
                        {
                            "name": "b",
                            "type": "Val"
                        }
                    ],
                    "return": "i64",
                    "docs": "Compare two objects, or at least one object to a non-object, structurally. Returns -1 if a<b, 1 if a>b, or 0 if a==b."
                },
                {
                    "export": "1",
                    "name": "contract_event",
                    "args": [
                        {
                            "name": "topics",
                            "type": "VecObject"
                        },
                        {
                            "name": "data",
                            "type": "Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Records a contract event. `topics` is expected to be a `SCVec` with length <= 4 that cannot contain `Vec`, `Map`, or `Bytes` with length > 32."
                },
                {
                    "export": "2",
                    "name": "get_ledger_version",
                    "args": [],
                    "return": "U32Val",
                    "docs": "Return the protocol version of the current ledger as a u32."
                },
                {
                    "export": "3",
                    "name": "get_ledger_sequence",
                    "args": [],
                    "return": "U32Val",
                    "docs": "Return the sequence number of the current ledger as a u32."
                },
                {
                    "export": "4",
                    "name": "get_ledger_timestamp",
                    "args": [],
                    "return": "U64Val",
                    "docs": "Return the timestamp number of the current ledger as a u64."
                },
                {
                    "export": "5",
                    "name": "fail_with_error",
                    "args": [
                        {
                            "name": "error",
                            "type": "Error"
                        }
                    ],
                    "return": "Void",
                    "docs": "Causes the currently executing contract to fail immediately with a provided error code, which must be of error-type `ScErrorType::Contract`. Does not actually return."
                },
                {
                    "export": "6",
                    "name": "get_ledger_network_id",
                    "args": [],
                    "return": "BytesObject",
                    "docs": "Return the network id (sha256 hash of network passphrase) of the current ledger as `Bytes`. The value is always 32 bytes in length."
                },
                {
                    "export": "7",
                    "name": "get_current_contract_address",
                    "args": [],
                    "return": "AddressObject",
                    "docs": "Get the Address object for the current contract."
                },
                {
                    "export": "8",
                    "name": "get_max_live_until_ledger",
                    "args": [],
                    "return": "U32Val",
                    "docs": "Returns the max ledger sequence that an entry can live to (inclusive)."
                }
            ]
        },
        {
            "name": "int",
            "export": "i",
            "functions": [
                {
                    "export": "_",
                    "name": "obj_from_u64",
                    "args": [
                        {
                            "name": "v",
                            "type": "u64"
                        }
                    ],
                    "return": "U64Object",
                    "docs": "Convert a `u64` to an object containing a `u64`."
                },
                {
                    "export": "0",
                    "name": "obj_to_u64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U64Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Convert an object containing a `u64` to a `u64`."
                },
                {
                    "export": "1",
                    "name": "obj_from_i64",
                    "args": [
                        {
                            "name": "v",
                            "type": "i64"
                        }
                    ],
                    "return": "I64Object",
                    "docs": "Convert an `i64` to an object containing an `i64`."
                },
                {
                    "export": "2",
                    "name": "obj_to_i64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I64Object"
                        }
                    ],
                    "return": "i64",
                    "docs": "Convert an object containing an `i64` to an `i64`."
                },
                {
                    "export": "3",
                    "name": "obj_from_u128_pieces",
                    "args": [
                        {
                            "name": "hi",
                            "type": "u64"
                        },
                        {
                            "name": "lo",
                            "type": "u64"
                        }
                    ],
                    "return": "U128Object",
                    "docs": "Convert the high and low 64-bit words of a u128 to an object containing a u128."
                },
                {
                    "export": "4",
                    "name": "obj_to_u128_lo64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U128Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the low 64 bits from an object containing a u128."
                },
                {
                    "export": "5",
                    "name": "obj_to_u128_hi64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U128Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the high 64 bits from an object containing a u128."
                },
                {
                    "export": "6",
                    "name": "obj_from_i128_pieces",
                    "args": [
                        {
                            "name": "hi",
                            "type": "i64"
                        },
                        {
                            "name": "lo",
                            "type": "u64"
                        }
                    ],
                    "return": "I128Object",
                    "docs": "Convert the high and low 64-bit words of an i128 to an object containing an i128."
                },
                {
                    "export": "7",
                    "name": "obj_to_i128_lo64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I128Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the low 64 bits from an object containing an i128."
                },
                {
                    "export": "8",
                    "name": "obj_to_i128_hi64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I128Object"
                        }
                    ],
                    "return": "i64",
                    "docs": "Extract the high 64 bits from an object containing an i128."
                },
                {
                    "export": "9",
                    "name": "obj_from_u256_pieces",
                    "args": [
                        {
                            "name": "hi_hi",
                            "type": "u64"
                        },
                        {
                            "name": "hi_lo",
                            "type": "u64"
                        },
                        {
                            "name": "lo_hi",
                            "type": "u64"
                        },
                        {
                            "name": "lo_lo",
                            "type": "u64"
                        }
                    ],
                    "return": "U256Object",
                    "docs": "Convert the four 64-bit words of a u256 (big-endian) to an object containing a u256."
                },
                {
                    "export": "a",
                    "name": "u256_val_from_be_bytes",
                    "args": [
                        {
                            "name": "bytes",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Create a U256 `Val` from its representation as a byte array in big endian."
                },
                {
                    "export": "b",
                    "name": "u256_val_to_be_bytes",
                    "args": [
                        {
                            "name": "val",
                            "type": "U256Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Return the memory representation of this U256 `Val` as a byte array in big endian byte order."
                },
                {
                    "export": "c",
                    "name": "obj_to_u256_hi_hi",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the highest 64-bits (bits 192-255) from an object containing a u256."
                },
                {
                    "export": "d",
                    "name": "obj_to_u256_hi_lo",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract bits 128-191 from an object containing a u256."
                },
                {
                    "export": "e",
                    "name": "obj_to_u256_lo_hi",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract bits 64-127 from an object containing a u256."
                },
                {
                    "export": "f",
                    "name": "obj_to_u256_lo_lo",
                    "args": [
                        {
                            "name": "obj",
                            "type": "U256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the lowest 64-bits (bits 0-63) from an object containing a u256."
                },
                {
                    "export": "g",
                    "name": "obj_from_i256_pieces",
                    "args": [
                        {
                            "name": "hi_hi",
                            "type": "i64"
                        },
                        {
                            "name": "hi_lo",
                            "type": "u64"
                        },
                        {
                            "name": "lo_hi",
                            "type": "u64"
                        },
                        {
                            "name": "lo_lo",
                            "type": "u64"
                        }
                    ],
                    "return": "I256Object",
                    "docs": "Convert the four 64-bit words of an i256 (big-endian) to an object containing an i256."
                },
                {
                    "export": "h",
                    "name": "i256_val_from_be_bytes",
                    "args": [
                        {
                            "name": "bytes",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Create a I256 `Val` from its representation as a byte array in big endian."
                },
                {
                    "export": "i",
                    "name": "i256_val_to_be_bytes",
                    "args": [
                        {
                            "name": "val",
                            "type": "I256Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Return the memory representation of this I256 `Val` as a byte array in big endian byte order."
                },
                {
                    "export": "j",
                    "name": "obj_to_i256_hi_hi",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I256Object"
                        }
                    ],
                    "return": "i64",
                    "docs": "Extract the highest 64-bits (bits 192-255) from an object containing an i256."
                },
                {
                    "export": "k",
                    "name": "obj_to_i256_hi_lo",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract bits 128-191 from an object containing an i256."
                },
                {
                    "export": "l",
                    "name": "obj_to_i256_lo_hi",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract bits 64-127 from an object containing an i256."
                },
                {
                    "export": "m",
                    "name": "obj_to_i256_lo_lo",
                    "args": [
                        {
                            "name": "obj",
                            "type": "I256Object"
                        }
                    ],
                    "return": "u64",
                    "docs": "Extract the lowest 64-bits (bits 0-63) from an object containing an i256."
                },
                {
                    "export": "n",
                    "name": "u256_add",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked integer addition. Computes `lhs + rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "o",
                    "name": "u256_sub",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked integer subtraction. Computes `lhs - rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "p",
                    "name": "u256_mul",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked integer multiplication. Computes `lhs * rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "q",
                    "name": "u256_div",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked integer division. Computes `lhs / rhs`, returning `ScError` if `rhs == 0` or overflow occurred. "
                },
                {
                    "export": "r",
                    "name": "u256_rem_euclid",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked Euclidean modulo. Computes `lhs % rhs`, returning `ScError` if `rhs == 0` or overflow occurred. "
                },
                {
                    "export": "s",
                    "name": "u256_pow",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked exponentiation. Computes `lhs.exp(rhs)`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "t",
                    "name": "u256_shl",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked shift left. Computes `lhs << rhs`, returning `ScError` if `rhs` is larger than or equal to the number of bits in `lhs`."
                },
                {
                    "export": "u",
                    "name": "u256_shr",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "Performs checked shift right. Computes `lhs >> rhs`, returning `ScError` if `rhs` is larger than or equal to the number of bits in `lhs`."
                },
                {
                    "export": "v",
                    "name": "i256_add",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "I256Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked integer addition. Computes `lhs + rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "w",
                    "name": "i256_sub",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "I256Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked integer subtraction. Computes `lhs - rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "x",
                    "name": "i256_mul",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "I256Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked integer multiplication. Computes `lhs * rhs`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "y",
                    "name": "i256_div",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "I256Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked integer division. Computes `lhs / rhs`, returning `ScError` if `rhs == 0` or overflow occurred. "
                },
                {
                    "export": "z",
                    "name": "i256_rem_euclid",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "I256Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked Euclidean modulo. Computes `lhs % rhs`, returning `ScError` if `rhs == 0` or overflow occurred. "
                },
                {
                    "export": "A",
                    "name": "i256_pow",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked exponentiation. Computes `lhs.exp(rhs)`, returning `ScError` if overflow occurred. "
                },
                {
                    "export": "B",
                    "name": "i256_shl",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked shift left. Computes `lhs << rhs`, returning `ScError` if `rhs` is larger than or equal to the number of bits in `lhs`."
                },
                {
                    "export": "C",
                    "name": "i256_shr",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "I256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U32Val"
                        }
                    ],
                    "return": "I256Val",
                    "docs": "Performs checked shift right. Computes `lhs >> rhs`, returning `ScError` if `rhs` is larger than or equal to the number of bits in `lhs`."
                },
                {
                    "export": "D",
                    "name": "timepoint_obj_from_u64",
                    "args": [
                        {
                            "name": "v",
                            "type": "u64"
                        }
                    ],
                    "return": "TimepointObject",
                    "docs": "Convert a `u64` to a `Timepoint` object."
                },
                {
                    "export": "E",
                    "name": "timepoint_obj_to_u64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "TimepointObject"
                        }
                    ],
                    "return": "u64",
                    "docs": "Convert a `Timepoint` object to a `u64`."
                },
                {
                    "export": "F",
                    "name": "duration_obj_from_u64",
                    "args": [
                        {
                            "name": "v",
                            "type": "u64"
                        }
                    ],
                    "return": "DurationObject",
                    "docs": "Convert a `u64` to a `Duration` object."
                },
                {
                    "export": "G",
                    "name": "duration_obj_to_u64",
                    "args": [
                        {
                            "name": "obj",
                            "type": "DurationObject"
                        }
                    ],
                    "return": "u64",
                    "docs": "Convert a `Duration` object a `u64`."
                }
            ]
        },
        {
            "name": "map",
            "export": "m",
            "functions": [
                {
                    "export": "_",
                    "name": "map_new",
                    "args": [],
                    "return": "MapObject",
                    "docs": "Create an empty new map."
                },
                {
                    "export": "0",
                    "name": "map_put",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "v",
                            "type": "Val"
                        }
                    ],
                    "return": "MapObject",
                    "docs": "Insert a key/value mapping into an existing map, and return the map object handle. If the map already has a mapping for the given key, the previous value is overwritten."
                },
                {
                    "export": "1",
                    "name": "map_get",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "k",
                            "type": "Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Get the value for a key from a map. Traps if key is not found."
                },
                {
                    "export": "2",
                    "name": "map_del",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "k",
                            "type": "Val"
                        }
                    ],
                    "return": "MapObject",
                    "docs": "Remove a key/value mapping from a map if it exists, traps if doesn't."
                },
                {
                    "export": "3",
                    "name": "map_len",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Get the size of a map."
                },
                {
                    "export": "4",
                    "name": "map_has",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "k",
                            "type": "Val"
                        }
                    ],
                    "return": "Bool",
                    "docs": "Test for the presence of a key in a map. Returns Bool."
                },
                {
                    "export": "5",
                    "name": "map_key_by_pos",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Get the key from a map at position `i`. If `i` is an invalid position, return ScError."
                },
                {
                    "export": "6",
                    "name": "map_val_by_pos",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Get the value from a map at position `i`. If `i` is an invalid position, return ScError."
                },
                {
                    "export": "7",
                    "name": "map_keys",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Return a new vector containing all the keys in a map. The new vector is ordered in the original map's key-sorted order."
                },
                {
                    "export": "8",
                    "name": "map_values",
                    "args": [
                        {
                            "name": "m",
                            "type": "MapObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Return a new vector containing all the values in a map. The new vector is ordered in the original map's key-sorted order."
                },
                {
                    "export": "9",
                    "name": "map_new_from_linear_memory",
                    "args": [
                        {
                            "name": "keys_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "vals_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "MapObject",
                    "docs": "Return a new map initialized from a pair of equal-length arrays, one for keys and one for values, given by a pair of linear-memory addresses and a length in Vals."
                },
                {
                    "export": "a",
                    "name": "map_unpack_to_linear_memory",
                    "args": [
                        {
                            "name": "map",
                            "type": "MapObject"
                        },
                        {
                            "name": "keys_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "vals_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Copy Vals from `map` to the array `vals_pos`, selecting only the keys identified by the array `keys_pos`. Both arrays have `len` elements and are identified by linear-memory addresses."
                }
            ]
        },
        {
            "name": "vec",
            "export": "v",
            "functions": [
                {
                    "export": "_",
                    "name": "vec_new",
                    "args": [],
                    "return": "VecObject",
                    "docs": "Creates an empty new vector."
                },
                {
                    "export": "0",
                    "name": "vec_put",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Update the value at index `i` in the vector. Return the new vector. Trap if the index is out of bounds."
                },
                {
                    "export": "1",
                    "name": "vec_get",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Returns the element at index `i` of the vector. Traps if the index is out of bound."
                },
                {
                    "export": "2",
                    "name": "vec_del",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Delete an element in a vector at index `i`, shifting all elements after it to the left. Return the new vector. Traps if the index is out of bound."
                },
                {
                    "export": "3",
                    "name": "vec_len",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Returns length of the vector."
                },
                {
                    "export": "4",
                    "name": "vec_push_front",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Push a value to the front of a vector."
                },
                {
                    "export": "5",
                    "name": "vec_pop_front",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Removes the first element from the vector and returns the new vector. Traps if original vector is empty."
                },
                {
                    "export": "6",
                    "name": "vec_push_back",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Appends an element to the back of the vector."
                },
                {
                    "export": "7",
                    "name": "vec_pop_back",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Removes the last element from the vector and returns the new vector. Traps if original vector is empty."
                },
                {
                    "export": "8",
                    "name": "vec_front",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Return the first element in the vector. Traps if the vector is empty"
                },
                {
                    "export": "9",
                    "name": "vec_back",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Return the last element in the vector. Traps if the vector is empty"
                },
                {
                    "export": "a",
                    "name": "vec_insert",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Inserts an element at index `i` within the vector, shifting all elements after it to the right. Traps if the index is out of bound"
                },
                {
                    "export": "b",
                    "name": "vec_append",
                    "args": [
                        {
                            "name": "v1",
                            "type": "VecObject"
                        },
                        {
                            "name": "v2",
                            "type": "VecObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Clone the vector `v1`, then moves all the elements of vector `v2` into it. Return the new vector. Traps if number of elements in the vector overflows a u32."
                },
                {
                    "export": "c",
                    "name": "vec_slice",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "start",
                            "type": "U32Val"
                        },
                        {
                            "name": "end",
                            "type": "U32Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Copy the elements from `start` index until `end` index, exclusive, in the vector and create a new vector from it. Return the new vector. Traps if the index is out of bound."
                },
                {
                    "export": "d",
                    "name": "vec_first_index_of",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Get the index of the first occurrence of a given element in the vector. Returns the u32 index of the value if it's there. Otherwise, it returns `Void`."
                },
                {
                    "export": "e",
                    "name": "vec_last_index_of",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "Val",
                    "docs": "Get the index of the last occurrence of a given element in the vector. Returns the u32 index of the value if it's there. Otherwise, it returns `Void`."
                },
                {
                    "export": "f",
                    "name": "vec_binary_search",
                    "args": [
                        {
                            "name": "v",
                            "type": "VecObject"
                        },
                        {
                            "name": "x",
                            "type": "Val"
                        }
                    ],
                    "return": "u64",
                    "docs": "Binary search a sorted vector for a given element. If it exists, the high 32 bits of the return value is 0x0000_0001 and the low 32 bits contain the u32 index of the element. If it does not exist, the high 32 bits of the return value is 0x0000_0000 and the low-32 bits contain the u32 index at which the element would need to be inserted into the vector to maintain sorted order."
                },
                {
                    "export": "g",
                    "name": "vec_new_from_linear_memory",
                    "args": [
                        {
                            "name": "vals_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Return a new vec initialized from an input slice of Vals given by a linear-memory address and length in Vals."
                },
                {
                    "export": "h",
                    "name": "vec_unpack_to_linear_memory",
                    "args": [
                        {
                            "name": "vec",
                            "type": "VecObject"
                        },
                        {
                            "name": "vals_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Copy the Vals of a vec into an array at a given linear-memory address and length in Vals."
                }
            ]
        },
        {
            "name": "ledger",
            "export": "l",
            "functions": [
                {
                    "export": "_",
                    "name": "put_contract_data",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "v",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        }
                    ],
                    "return": "Void"
                },
                {
                    "export": "0",
                    "name": "has_contract_data",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        }
                    ],
                    "return": "Bool"
                },
                {
                    "export": "1",
                    "name": "get_contract_data",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        }
                    ],
                    "return": "Val"
                },
                {
                    "export": "2",
                    "name": "del_contract_data",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        }
                    ],
                    "return": "Void"
                },
                {
                    "export": "3",
                    "name": "create_contract",
                    "args": [
                        {
                            "name": "deployer",
                            "type": "AddressObject"
                        },
                        {
                            "name": "wasm_hash",
                            "type": "BytesObject"
                        },
                        {
                            "name": "salt",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Creates the contract instance on behalf of `deployer`. `deployer` must authorize this call via Soroban auth framework, i.e. this calls `deployer.require_auth` with respective arguments. `wasm_hash` must be a hash of the contract code that has already been uploaded on this network. `salt` is used to create a unique contract id. Returns the address of the created contract."
                },
                {
                    "export": "4",
                    "name": "create_asset_contract",
                    "args": [
                        {
                            "name": "serialized_asset",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Creates the instance of Stellar Asset contract corresponding to the provided asset. `serialized_asset` is `stellar::Asset` XDR serialized to bytes format. Returns the address of the created contract."
                },
                {
                    "export": "5",
                    "name": "upload_wasm",
                    "args": [
                        {
                            "name": "wasm",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Uploads provided `wasm` bytecode to the network and returns its identifier (SHA-256 hash). No-op in case if the same Wasm object already exists."
                },
                {
                    "export": "6",
                    "name": "update_current_contract_wasm",
                    "args": [
                        {
                            "name": "hash",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Replaces the executable of the current contract with the provided Wasm code identified by a hash. Wasm entry corresponding to the hash has to already be present in the ledger. The update happens only after the current contract invocation has successfully finished, so this can be safely called in the middle of a function."
                },
                {
                    "export": "7",
                    "name": "extend_contract_data_ttl",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        },
                        {
                            "name": "threshold",
                            "type": "U32Val"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "If the entry's TTL is below `threshold` ledgers, extend `live_until_ledger_seq` such that TTL == `extend_to`, where TTL is defined as live_until_ledger_seq - current ledger. If attempting to extend the entry past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), and the entry is `Persistent`, its new `live_until_ledger_seq` will be clamped to the max; if the entry is `Temporary`, the function traps."
                },
                {
                    "export": "8",
                    "name": "extend_current_contract_instance_and_code_ttl",
                    "args": [
                        {
                            "name": "threshold",
                            "type": "U32Val"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "If the TTL for the current contract instance and code (if applicable) is below `threshold` ledgers, extend `live_until_ledger_seq` such that TTL == `extend_to`, where TTL is defined as live_until_ledger_seq - current ledger. If attempting to extend past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), the new `live_until_ledger_seq` will be clamped to the max."
                },
                {
                    "export": "9",
                    "name": "extend_contract_instance_and_code_ttl",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "threshold",
                            "type": "U32Val"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "If the TTL for the provided contract instance and code (if applicable) is below `threshold` ledgers, extend `live_until_ledger_seq` such that TTL == `extend_to`, where TTL is defined as live_until_ledger_seq - current ledger. If attempting to extend past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), the new `live_until_ledger_seq` will be clamped to the max."
                },
                {
                    "export": "a",
                    "name": "get_contract_id",
                    "args": [
                        {
                            "name": "deployer",
                            "type": "AddressObject"
                        },
                        {
                            "name": "salt",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Get the id of a contract without creating it. `deployer` is address of the contract deployer. `salt` is used to create a unique contract id. Returns the address of the would-be contract."
                },
                {
                    "export": "b",
                    "name": "get_asset_contract_id",
                    "args": [
                        {
                            "name": "serialized_asset",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs":  "Get the id of the Stellar Asset contract corresponding to the provided asset without creating the instance. `serialized_asset` is `stellar::Asset` XDR serialized to bytes format. Returns the address of the would-be asset contract."
                },
                {
                    "export": "c",
                    "name": "extend_contract_instance_ttl",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "threshold",
                            "type": "U32Val"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "If the TTL for the provided contract instance is below `threshold` ledgers, extend `live_until_ledger_seq` such that TTL == `extend_to`, where TTL is defined as live_until_ledger_seq - current ledger. If attempting to extend past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), the new `live_until_ledger_seq` will be clamped to the max.",
                    "min_supported_protocol": 21
                },
                {
                    "export": "d",
                    "name": "extend_contract_code_ttl",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "threshold",
                            "type": "U32Val"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "If the TTL for the provided contract's code (if applicable) is below `threshold` ledgers, extend `live_until_ledger_seq` such that TTL == `extend_to`, where TTL is defined as live_until_ledger_seq - current ledger. If attempting to extend past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), the new `live_until_ledger_seq` will be clamped to the max.",
                    "min_supported_protocol": 21
                },
                {
                    "export": "e",
                    "name": "create_contract_with_constructor",
                    "args": [
                        {
                            "name": "deployer",
                            "type": "AddressObject"
                        },
                        {
                            "name": "wasm_hash",
                            "type": "BytesObject"
                        },
                        {
                            "name": "salt",
                            "type": "BytesObject"
                        },
                        {
                            "name": "constructor_args",
                            "type": "VecObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Creates the contract instance on behalf of `deployer`. Created contract must be created from a Wasm that has a constructor. `deployer` must authorize this call via Soroban auth framework, i.e. this calls `deployer.require_auth` with respective arguments. `wasm_hash` must be a hash of the contract code that has already been uploaded on this network. `salt` is used to create a unique contract id. `constructor_args` are forwarded into created contract's constructor (`__constructor`) function. Returns the address of the created contract.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "f",
                    "name": "extend_contract_data_ttl_v2",
                    "args": [
                        {
                            "name": "k",
                            "type": "Val"
                        },
                        {
                            "name": "t",
                            "type": "StorageType"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        },
                        {
                            "name": "min_extension",
                            "type": "U32Val"
                        },
                        {
                            "name": "max_extension",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Extend the contract data entry's TTL to be up to `extend_to` ledgers, where TTL is defined as `entry_live_until_ledger_seq - current_ledger_seq`. The TTL extension only actually happens if it is at least `min_extension`, otherwise this function is a no-op. The amount of extension ledgers will not exceed `max_extension` ledgers. If attempting to extend the entry past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), and the entry is `Persistent`, its new `live_until_ledger_seq` will be clamped to the max; if the entry is `Temporary`, the function traps.",
                    "min_supported_protocol": 26
                },
                {
                    "export": "g",
                    "name": "extend_contract_instance_and_code_ttl_v2",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "extension_scope",
                            "type": "ContractTTLExtension"
                        },
                        {
                            "name": "extend_to",
                            "type": "U32Val"
                        },
                        {
                            "name": "min_extension",
                            "type": "U32Val"
                        },
                        {
                            "name": "max_extension",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Extend the contract instance and/or corresponding code entry TTL to be up to `extend_to` ledgers, where TTL is defined as `entry_live_until_ledger_seq - current_ledger_seq`. `extension_scope` defines whether contract instance, code, or both will be extended. The TTL extension only actually happens if it is at least `min_extension`, otherwise this function is a no-op. The amount of extension ledgers will not exceed `max_extension` ledgers. If attempting to extend an entry past the maximum allowed value (defined as the current ledger + `max_entry_ttl` - 1), its new `live_until_ledger_seq` will be clamped to the max.",
                    "min_supported_protocol": 26
                }
            ]
        },
        {
            "name": "call",
            "export": "d",
            "functions": [
                {
                    "export": "_",
                    "name": "call",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "func",
                            "type": "Symbol"
                        },
                        {
                            "name": "args",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Calls a function in another contract with arguments contained in vector `args`. If the call is successful, returns the result of the called function. Traps otherwise."
                },
                {
                    "export": "0",
                    "name": "try_call",
                    "args": [
                        {
                            "name": "contract",
                            "type": "AddressObject"
                        },
                        {
                            "name": "func",
                            "type": "Symbol"
                        },
                        {
                            "name": "args",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Calls a function in another contract with arguments contained in vector `args`, returning either the result of the called function or an `Error` if the called function failed. The returned error is either a custom `ContractError` that the called contract returns explicitly, or an error with type `Context` and code `InvalidAction` in case of any other error in the called contract (such as a host function failure that caused a trap). `try_call` might trap in a few scenarios where the error can't be meaningfully recovered from, such as running out of budget."
                }
            ]
        },
        {
            "name": "buf",
            "export": "b",
            "functions": [
                {
                    "export": "_",
                    "name": "serialize_to_bytes",
                    "args": [
                        {
                            "name": "v",
                            "type": "Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Serializes an (SC)Val into XDR opaque `Bytes` object."
                },
                {
                    "export": "0",
                    "name": "deserialize_from_bytes",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Deserialize a `Bytes` object to get back the (SC)Val."
                },
                {
                    "export": "1",
                    "name": "bytes_copy_to_linear_memory",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "b_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Copies a slice of bytes from a `Bytes` object specified at offset `b_pos` with length `len` into the linear memory at position `lm_pos`. Traps if either the `Bytes` object or the linear memory doesn't have enough bytes."
                },
                {
                    "export": "2",
                    "name": "bytes_copy_from_linear_memory",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "b_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Copies a segment of the linear memory specified at position `lm_pos` with length `len`, into a `Bytes` object at offset `b_pos`. The `Bytes` object may grow in size to accommodate the new bytes. Traps if the linear memory doesn't have enough bytes."
                },
                {
                    "export": "3",
                    "name": "bytes_new_from_linear_memory",
                    "args": [
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Constructs a new `Bytes` object initialized with bytes copied from a linear memory slice specified at position `lm_pos` with length `len`."
                },
                {
                    "export": "4",
                    "name": "bytes_new",
                    "args": [],
                    "return": "BytesObject",
                    "docs": "Create an empty new `Bytes` object."
                },
                {
                    "export": "5",
                    "name": "bytes_put",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        },
                        {
                            "name": "u",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Update the value at index `i` in the `Bytes` object. Return the new `Bytes`. Trap if the index is out of bounds."
                },
                {
                    "export": "6",
                    "name": "bytes_get",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Returns the element at index `i` of the `Bytes` object. Traps if the index is out of bound."
                },
                {
                    "export": "7",
                    "name": "bytes_del",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Delete an element in a `Bytes` object at index `i`, shifting all elements after it to the left. Return the new `Bytes`. Traps if the index is out of bound."
                },
                {
                    "export": "8",
                    "name": "bytes_len",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Returns length of the `Bytes` object."
                },
                {
                    "export": "9",
                    "name": "bytes_push",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "u",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Appends an element to the back of the `Bytes` object."
                },
                {
                    "export": "a",
                    "name": "bytes_pop",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Removes the last element from the `Bytes` object and returns the new `Bytes`. Traps if original `Bytes` is empty."
                },
                {
                    "export": "b",
                    "name": "bytes_front",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Return the first element in the `Bytes` object. Traps if the `Bytes` is empty"
                },
                {
                    "export": "c",
                    "name": "bytes_back",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Return the last element in the `Bytes` object. Traps if the `Bytes` is empty"
                },
                {
                    "export": "d",
                    "name": "bytes_insert",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "i",
                            "type": "U32Val"
                        },
                        {
                            "name": "u",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Inserts an element at index `i` within the `Bytes` object, shifting all elements after it to the right. Traps if the index is out of bound"
                },
                {
                    "export": "e",
                    "name": "bytes_append",
                    "args": [
                        {
                            "name": "b1",
                            "type": "BytesObject"
                        },
                        {
                            "name": "b2",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Clone the `Bytes` object `b1`, then moves all the elements of `Bytes` object `b2` into it. Return the new `Bytes`. Traps if its length overflows a u32."
                },
                {
                    "export": "f",
                    "name": "bytes_slice",
                    "args": [
                        {
                            "name": "b",
                            "type": "BytesObject"
                        },
                        {
                            "name": "start",
                            "type": "U32Val"
                        },
                        {
                            "name": "end",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Copies the elements from `start` index until `end` index, exclusive, in the `Bytes` object and creates a new `Bytes` from it. Returns the new `Bytes`. Traps if the index is out of bound."
                },
                {
                    "export": "g",
                    "name": "string_copy_to_linear_memory",
                    "args": [
                        {
                            "name": "s",
                            "type": "StringObject"
                        },
                        {
                            "name": "s_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Copies a slice of bytes from a `String` object specified at offset `s_pos` with length `len` into the linear memory at position `lm_pos`. Traps if either the `String` object or the linear memory doesn't have enough bytes."
                },
                {
                    "export": "h",
                    "name": "symbol_copy_to_linear_memory",
                    "args": [
                        {
                            "name": "s",
                            "type": "SymbolObject"
                        },
                        {
                            "name": "s_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "Void",
                    "docs": "Copies a slice of bytes from a `Symbol` object specified at offset `s_pos` with length `len` into the linear memory at position `lm_pos`. Traps if either the `String` object or the linear memory doesn't have enough bytes."
                },
                {
                    "export": "i",
                    "name": "string_new_from_linear_memory",
                    "args": [
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "StringObject",
                    "docs": "Constructs a new `String` object initialized with bytes copied from a linear memory slice specified at position `lm_pos` with length `len`."
                },
                {
                    "export": "j",
                    "name": "symbol_new_from_linear_memory",
                    "args": [
                        {
                            "name": "lm_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "SymbolObject",
                    "docs": "Constructs a new `Symbol` object initialized with bytes copied from a linear memory slice specified at position `lm_pos` with length `len`."
                },
                {
                    "export": "k",
                    "name": "string_len",
                    "args": [
                        {
                            "name": "s",
                            "type": "StringObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Returns length of the `String` object."
                },
                {
                    "export": "l",
                    "name": "symbol_len",
                    "args": [
                        {
                            "name": "s",
                            "type": "SymbolObject"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Returns length of the `Symbol` object."
                },
                {
                    "export": "m",
                    "name": "symbol_index_in_linear_memory",
                    "args": [
                        {
                            "name": "sym",
                            "type": "Symbol"
                        },
                        {
                            "name": "slices_pos",
                            "type": "U32Val"
                        },
                        {
                            "name": "len",
                            "type": "U32Val"
                        }
                    ],
                    "return": "U32Val",
                    "docs": "Return the index of a Symbol in an array of linear-memory byte-slices, or trap if not found."
                },
                {
                    "export": "n",
                    "name": "string_to_bytes",
                    "args": [
                        {
                            "name": "str",
                            "type": "StringObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Converts the provided string to bytes with exactly the same contents.",
                    "min_supported_protocol": 23
                },
                {
                    "export": "o",
                    "name": "bytes_to_string",
                    "args": [
                        {
                            "name": "bytes",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "StringObject",
                    "docs": "Converts the provided bytes array to string with exactly the same contents. No encoding checks are performed and thus the output string's encoding should be interpreted by the consumer of the string.",
                    "min_supported_protocol": 23
                }
            ]
        },
        {
            "name": "crypto",
            "export": "c",
            "functions": [
                {
                    "export": "_",
                    "name": "compute_hash_sha256",
                    "args": [
                        {
                            "name": "x",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject"
                },
                {
                    "export": "0",
                    "name": "verify_sig_ed25519",
                    "args": [
                        {
                            "name": "k",
                            "type": "BytesObject"
                        },
                        {
                            "name": "x",
                            "type": "BytesObject"
                        },
                        {
                            "name": "s",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Void"
                },
                {
                    "export": "1",
                    "name": "compute_hash_keccak256",
                    "args": [
                        {
                            "name": "x",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Returns the keccak256 hash of given input bytes."
                },
                {
                    "export": "2",
                    "name": "recover_key_ecdsa_secp256k1",
                    "args": [
                        {
                            "name": "msg_digest",
                            "type": "BytesObject"
                        },
                        {
                            "name": "signature",
                            "type": "BytesObject"
                        },
                        {
                            "name": "recovery_id",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Recovers the SEC-1-encoded ECDSA secp256k1 public key that produced a given 64-byte `signature` over a given 32-byte `msg_digest` for a given `recovery_id` byte. Warning: The `msg_digest` must be produced by a secure cryptographic hash function on the message, otherwise the attacker can potentially forge signatures.  The `signature` is the ECDSA signature `(r, s)` serialized as fixed-size big endian scalar values, both `r`, `s` must be non-zero and `s` must be in the lower range. Returns a `BytesObject` containing 65-bytes representing SEC-1 encoded point in uncompressed format. The `recovery_id` is an integer value `0`, `1`, `2`, or `3`, the low bit (0/1) indicates the parity of the y-coordinate of the `public_key` (even/odd) and the high bit (3/4) indicate if the `r` (x-coordinate of `k x G`) has overflown during its computation."
                },
                {
                    "export": "3",
                    "name": "verify_sig_ecdsa_secp256r1",
                    "args": [
                        {
                            "name": "public_key",
                            "type": "BytesObject"
                        },
                        {
                            "name": "msg_digest",
                            "type": "BytesObject"
                        },
                        {
                            "name": "signature",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Verifies the `signature` using an ECDSA secp256r1 `public_key` on a 32-byte `msg_digest`. Warning: The `msg_digest` must be produced by a secure cryptographic hash function on the message, otherwise the attacker can potentially forge signatures. The `public_key` is expected to be 65 bytes in length, representing a SEC-1 encoded point in uncompressed format. The `signature` is the ECDSA signature `(r, s)` serialized as fixed-size big endian scalar values, both `r`, `s` must be non-zero and `s` must be in the lower range. ",
                    "min_supported_protocol": 21
                },
                {
                    "export": "4",
                    "name": "bls12_381_check_g1_is_in_subgroup",
                    "args": [
                        {
                            "name": "point",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Bool",
                    "docs": "Checks if the input G1 point is in the correct subgroup. This function will error if `point` is not on the curve",
                    "min_supported_protocol": 22
                },
                {
                    "export": "5",
                    "name": "bls12_381_g1_add",
                    "args": [
                        {
                            "name": "point1",
                            "type": "BytesObject"
                        },
                        {
                            "name": "point2",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Adds two BLS12-381 G1 points given in bytes format and returns the resulting G1 point in bytes format. G1 serialization format: `concat(be_bytes(X), be_bytes(Y))` and the most significant three bits of X encodes flags, i.e.  bits(X) = [compression_flag, infinity_flag, sort_flag, bit_3, .. bit_383]. This function does NOT perform subgroup check on the inputs.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "6",
                    "name": "bls12_381_g1_mul",
                    "args": [
                        {
                            "name": "point",
                            "type": "BytesObject"
                        },
                        {
                            "name": "scalar",
                            "type": "U256Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Multiplies a BLS12-381 G1 point by a scalar (Fr), and returns the resulting G1 point in bytes format.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "7",
                    "name": "bls12_381_g1_msm",
                    "args": [
                        {
                            "name": "vp",
                            "type": "VecObject"
                        },
                        {
                            "name": "vs",
                            "type": "VecObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Performs multi-scalar-multiplication (inner product) on a vector of BLS12-381 G1 points (`Vec<BytesObject>`) by a vector of scalars (`Vec<U256Val>`), and returns the resulting G1 point in bytes format.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "8",
                    "name": "bls12_381_map_fp_to_g1",
                    "args": [
                        {
                            "name": "fp",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Maps a BLS12-381 field element (Fp) to G1 point. The input is a BytesObject containing Fp serialized in big-endian order",
                    "min_supported_protocol": 22
                },
                {
                    "export": "9",
                    "name": "bls12_381_hash_to_g1",
                    "args": [
                        {
                            "name": "msg",
                            "type": "BytesObject"
                        },
                        {
                            "name": "dst",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Hashes a message to a BLS12-381 G1 point, with implementation following the specification in [Hashing to Elliptic Curves](https://datatracker.ietf.org/doc/html/rfc9380) (ciphersuite 'BLS12381G1_XMD:SHA-256_SSWU_RO_'). `dst` is the domain separation tag that will be concatenated with the `msg` during hashing, it is intended to keep hashing inputs of different applications separate. It is required `0 < len(dst_bytes) < 256`. DST **must** be chosen with care to avoid compromising the application's security properties. Refer to section 3.1 in the RFC on requirements of DST.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "a",
                    "name": "bls12_381_check_g2_is_in_subgroup",
                    "args": [
                        {
                            "name": "point",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Bool",
                    "docs": "Checks if the input G2 point is in the correct subgroup. This function will error if `point` is not on the curve",
                    "min_supported_protocol": 22
                },
                {
                    "export": "b",
                    "name": "bls12_381_g2_add",
                    "args": [
                        {
                            "name": "point1",
                            "type": "BytesObject"
                        },
                        {
                            "name": "point2",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Adds two BLS12-381 G2 points given in bytes format and returns the resulting G2 point in bytes format. G2 serialization format: concat(be_bytes(X_c1), be_bytes(X_c0), be_bytes(Y_c1), be_bytes(Y_c0)), and the most significant three bits of X_c1 are flags i.e. bits(X_c1) = [compression_flag, infinity_flag, sort_flag, bit_3, .. bit_383]. This function does NOT perform subgroup check on the inputs.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "c",
                    "name": "bls12_381_g2_mul",
                    "args": [
                        {
                            "name": "point",
                            "type": "BytesObject"
                        },
                        {
                            "name": "scalar",
                            "type": "U256Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Multiplies a BLS12-381 G2 point by a scalar (Fr), and returns the resulting G2 point in bytes format.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "d",
                    "name": "bls12_381_g2_msm",
                    "args": [
                        {
                            "name": "vp",
                            "type": "VecObject"
                        },
                        {
                            "name": "vs",
                            "type": "VecObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Performs multi-scalar-multiplication (inner product) on a vector of BLS12-381 G2 points (`Vec<BytesObject>`) by a vector of scalars (`Vec<U256Val>`) , and returns the resulting G2 point in bytes format.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "e",
                    "name": "bls12_381_map_fp2_to_g2",
                    "args": [
                        {
                            "name": "fp2",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Maps a BLS12-381 quadratic extension field element (Fp2) to G2 point. Fp2 serialization format: concat(be_bytes(c1), be_bytes(c0))",
                    "min_supported_protocol": 22
                },
                {
                    "export": "f",
                    "name": "bls12_381_hash_to_g2",
                    "args": [
                        {
                            "name": "msg",
                            "type": "BytesObject"
                        },
                        {
                            "name": "dst",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Hashes a message to a BLS12-381 G2 point, with implementation following the specification in [Hashing to Elliptic Curves](https://datatracker.ietf.org/doc/html/rfc9380) (ciphersuite 'BLS12381G2_XMD:SHA-256_SSWU_RO_'). `dst` is the domain separation tag that will be concatenated with the `msg` during hashing, it is intended to keep hashing inputs of different applications separate. It is required `0 < len(dst_bytes) < 256`. DST **must** be chosen with care to avoid compromising the application's security properties. Refer to section 3.1 in the RFC on requirements of DST.",
                    "min_supported_protocol": 22
                },
                {
                    "export": "g",
                    "name": "bls12_381_multi_pairing_check",
                    "args": [
                        {
                            "name": "vp1",
                            "type": "VecObject"
                        },
                        {
                            "name": "vp2",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Bool",
                    "docs": "performs pairing operation on a vector of `G1` (`Vec<BytesObject>`)  and a vector of `G2` points (`Vec<BytesObject>`) , return true if the result equals `1_fp12`",
                    "min_supported_protocol": 22
                },
                {
                    "export": "h",
                    "name": "bls12_381_fr_add",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "performs addition `(lhs + rhs) mod r` between two BLS12-381 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 22
                },
                {
                    "export": "i",
                    "name": "bls12_381_fr_sub",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "performs subtraction `(lhs - rhs) mod r` between two BLS12-381 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 22
                },
                {
                    "export": "j",
                    "name": "bls12_381_fr_mul",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "performs multiplication `(lhs * rhs) mod r` between two BLS12-381 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 22
                },
                {
                    "export": "k",
                    "name": "bls12_381_fr_pow",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        },
                        {
                            "name": "rhs",
                            "type": "U64Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "performs exponentiation of a BLS12-381 scalar element (Fr) with a u64 exponent i.e. `lhs.exp(rhs) mod r`, where r is the subgroup order",
                    "min_supported_protocol": 22
                },
                {
                    "export": "l",
                    "name": "bls12_381_fr_inv",
                    "args": [
                        {
                            "name": "lhs",
                            "type": "U256Val"
                        }
                    ],
                    "return": "U256Val",
                    "docs": "performs inversion of a BLS12-381 scalar element (Fr) modulo r (the subgroup order)",
                    "min_supported_protocol": 22
                },
                {
                    "export": "m",
                    "name": "bn254_g1_add",
                    "args": [
                        { "name": "point1", "type": "BytesObject" },
                        { "name": "point2", "type": "BytesObject" }
                    ],
                    "return": "BytesObject",
                    "docs": "Adds two BN254 G1 points. G1 encoding: 64-byte uncompressed format: be_bytes(X)||be_bytes(Y), where X and Y are 32-byte big-endian Fp field elements. The two flag bits (0x80 and 0x40) of the first byte must be unset -- infinity is represented as 64 zero bytes. Points must be on curve with no subgroup check needed (always in subgroup)",
                    "min_supported_protocol": 25
                },
                {
                    "export": "n",
                    "name": "bn254_g1_mul",
                    "args": [
                        { "name": "point", "type": "BytesObject" },
                        { "name": "scalar", "type": "U256Val" }
                    ],
                    "return": "BytesObject",
                    "docs": "Multiplies a BN254 G1 point by a scalar from the scalar field Fr. The point uses the same 64-byte encoding as bn254_g1_add. The scalar is a U256Val representing a 256-bit integer that is reduced modulo the Fr field order.",
                    "min_supported_protocol": 25
                },
                {
                    "export": "o",
                    "name": "bn254_multi_pairing_check",
                    "args": [
                        { "name": "vp1", "type": "VecObject" },
                        { "name": "vp2", "type": "VecObject" }
                    ],
                    "return": "Bool",
                    "docs": "Performs BN254 multi-pairing check over equal-length non-empty vectors of G1 and G2 points. Returns true iff the product of pairings e(G1[0],G2[0])*...*e(G1[n-1],G2[n-1]) equals 1 in Fq12. G1 encoding: 64 bytes as in bn254_g1_add. G2 encoding: 128-byte uncompressed format: be_bytes(X)||be_bytes(Y), where X and Y are Fp2 elements (64 bytes each). Fp2 element encoding: be_bytes(c1)||be_bytes(c0) where c0 is the real part and c1 is the imaginary part (each 32-byte big-endian Fp). The two flag bits (0x80 and 0x40) of the first byte must be unset -- G2 infinity is 128 zero bytes. G2 points must be on curve AND in the correct subgroup.",
                    "min_supported_protocol": 25
                },
                {
                    "export": "p",
                    "name": "poseidon_permutation",
                    "args": [
                        { "name": "input", "type": "VecObject" },
                        { "name": "field", "type": "Symbol" },
                        { "name": "t", "type": "U32Val" },
                        { "name": "d", "type": "U32Val" },
                        { "name": "rounds_f", "type": "U32Val" },
                        { "name": "rounds_p", "type": "U32Val" },
                        { "name": "mds", "type": "VecObject" },
                        { "name": "round_constants", "type": "VecObject" }
                    ],
                    "return": "VecObject",
                    "docs": "Performs Poseidon permutation on input vector. input: vector of field elements (length t). field: 'BLS12_381' or 'BN254'. t: state size. d: S-box degree (5 for BLS12_381/BN254). rounds_f: number of full rounds (must be even). rounds_p: number of partial rounds. mds: t-by-t MDS matrix as Vec<Vec<Scalar>>. round_constants: (rounds_f+rounds_p)-by-t round constants matrix as Vec<Vec<Scalar>>. Returns output vector after permutation.",
                    "min_supported_protocol": 25
                },
                {
                    "export": "q",
                    "name": "poseidon2_permutation",
                    "args": [
                        { "name": "input", "type": "VecObject" },
                        { "name": "field", "type": "Symbol" },
                        { "name": "t", "type": "U32Val" },
                        { "name": "d", "type": "U32Val" },
                        { "name": "rounds_f", "type": "U32Val" },
                        { "name": "rounds_p", "type": "U32Val" },
                        { "name": "mat_internal_diag_m_1", "type": "VecObject" },
                        { "name": "round_constants", "type": "VecObject" }
                    ],
                    "return": "VecObject",
                    "docs": "Performs Poseidon2 permutation on input vector. input: vector of field elements (length t). field: 'BLS12_381' or 'BN254'. t: state size. d: S-box degree (5 for BLS12_381/BN254). rounds_f: number of full rounds (must be even). rounds_p: number of partial rounds. mat_internal_diag_m_1: internal matrix diagonal minus 1 as Vec<Scalar> (length t). round_constants: (rounds_f+rounds_p)-by-t round constants matrix as Vec<Vec<Scalar>>. Returns output vector after permutation.",
                    "min_supported_protocol": 25
                },
                {
                    "export": "r",
                    "name": "bn254_g1_msm",
                    "args": [
                        { "name": "vp", "type": "VecObject" },
                        { "name": "vs", "type": "VecObject" }
                    ],
                    "return": "BytesObject",
                    "docs": "Performs multi-scalar-multiplication (inner product) on a vector of BN254 G1 points (`Vec<BytesObject>`) by a vector of scalars (`Vec<U256Val>`), and returns the resulting G1 point in 64-byte uncompressed format.",
                    "min_supported_protocol": 26
                },
                {
                    "export": "s",
                    "name": "bn254_fr_add",
                    "args": [
                        { "name": "lhs", "type": "U256Val" },
                        { "name": "rhs", "type": "U256Val" }
                    ],
                    "return": "U256Val",
                    "docs": "Performs addition `(lhs + rhs) mod r` between two BN254 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 26
                },
                {
                    "export": "t",
                    "name": "bn254_fr_sub",
                    "args": [
                        { "name": "lhs", "type": "U256Val" },
                        { "name": "rhs", "type": "U256Val" }
                    ],
                    "return": "U256Val",
                    "docs": "Performs subtraction `(lhs - rhs) mod r` between two BN254 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 26
                },
                {
                    "export": "u",
                    "name": "bn254_fr_mul",
                    "args": [
                        { "name": "lhs", "type": "U256Val" },
                        { "name": "rhs", "type": "U256Val" }
                    ],
                    "return": "U256Val",
                    "docs": "Performs multiplication `(lhs * rhs) mod r` between two BN254 scalar elements (Fr), where r is the subgroup order",
                    "min_supported_protocol": 26
                },
                {
                    "export": "v",
                    "name": "bn254_fr_pow",
                    "args": [
                        { "name": "lhs", "type": "U256Val" },
                        { "name": "rhs", "type": "U64Val" }
                    ],
                    "return": "U256Val",
                    "docs": "Performs exponentiation of a BN254 scalar element (Fr) with a u64 exponent i.e. `lhs.exp(rhs) mod r`, where r is the subgroup order",
                    "min_supported_protocol": 26
                },
                {
                    "export": "w",
                    "name": "bn254_fr_inv",
                    "args": [
                        { "name": "lhs", "type": "U256Val" }
                    ],
                    "return": "U256Val",
                    "docs": "Performs inversion of a BN254 scalar element (Fr) modulo r (the subgroup order)",
                    "min_supported_protocol": 26
                },
                {
                    "export": "x",
                    "name": "bls12_381_g1_is_on_curve",
                    "args": [
                        { "name": "point", "type": "BytesObject" }
                    ],
                    "return": "Bool",
                    "docs": "Checks if a BLS12-381 G1 point is on the curve (does not check subgroup membership). Returns true if the point is on the curve, false otherwise.",
                    "min_supported_protocol": 26
                },
                {
                    "export": "y",
                    "name": "bls12_381_g2_is_on_curve",
                    "args": [
                        { "name": "point", "type": "BytesObject" }
                    ],
                    "return": "Bool",
                    "docs": "Checks if a BLS12-381 G2 point is on the curve (does not check subgroup membership). Returns true if the point is on the curve, false otherwise.",
                    "min_supported_protocol": 26
                },
                {
                    "export": "z",
                    "name": "bn254_g1_is_on_curve",
                    "args": [
                        { "name": "point", "type": "BytesObject" }
                    ],
                    "return": "Bool",
                    "docs": "Checks if a BN254 G1 point is on the curve. Returns true if the point is on the curve, false otherwise.",
                    "min_supported_protocol": 26
                }
            ]
        },
        {
            "name": "address",
            "export": "a",
            "functions": [
                {
                    "export": "_",
                    "name": "require_auth_for_args",
                    "args": [
                        {
                            "name": "address",
                            "type": "AddressObject"
                        },
                        {
                            "name": "args",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Checks if the address has authorized the invocation of the current contract function with the provided arguments. Traps if the invocation hasn't been authorized."
                },
                {
                    "export": "0",
                    "name": "require_auth",
                    "args": [
                        {
                            "name": "address",
                            "type": "AddressObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Checks if the address has authorized the invocation of the current contract function with all the arguments of the invocation. Traps if the invocation hasn't been authorized."
                },
                {
                    "export": "1",
                    "name": "strkey_to_address",
                    "args": [
                        {
                            "name": "strkey",
                            "type": "Val"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Converts a provided Stellar strkey address of an account or a contract ('G...' or 'C...' respectively) to an address object. `strkey` can be either `BytesObject` or `StringObject` (the contents should represent the `G.../C...` string in both cases). Any other valid or invalid strkey (e.g. 'S...') will trigger an error. Prefer directly using the Address objects whenever possible. This is only useful in the context of custom messaging protocols (e.g. cross-chain)."
                },
                {
                    "export": "2",
                    "name": "address_to_strkey",
                    "args": [
                        {
                            "name": "address",
                            "type": "AddressObject"
                        }
                    ],
                    "return": "StringObject",
                    "docs": "Converts a provided address to Stellar strkey format ('G...' for account or 'C...' for contract). Prefer directly using the Address objects whenever possible. This is only useful in the context of custom messaging protocols (e.g. cross-chain)."
                },
                {
                    "export": "3",
                    "name": "authorize_as_curr_contract",
                    "args": [
                        {
                            "name": "auth_entires",
                            "type": "VecObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Authorizes sub-contract calls for the next contract call on behalf of the current contract. Every entry in the argument vector corresponds to `InvokerContractAuthEntry` contract type that authorizes a tree of `require_auth` calls on behalf of the current contract. The entries must not contain any authorizations for the direct contract call, i.e. if current contract needs to call contract function F1 that calls function F2 both of which require auth, only F2 should be present in `auth_entries`."
                },
                {
                    "export": "4",
                    "name": "get_address_from_muxed_address",
                    "args": [
                        {
                            "name": "muxed_address",
                            "type": "MuxedAddressObject"
                        }
                    ],
                    "return": "AddressObject",
                    "docs": "Returns the address corresponding to the provided MuxedAddressObject as a new AddressObject. Note, that MuxedAddressObject consists of the address and multiplexing id, so this conversion just strips the multiplexing id from the input muxed address.",
                    "min_supported_protocol": 23
                },
                {
                    "export": "5",
                    "name": "get_id_from_muxed_address",
                    "args": [
                        {
                            "name": "muxed_address",
                            "type": "MuxedAddressObject"
                        }
                    ],
                    "return": "U64Val",
                    "docs": "Returns the multiplexing id corresponding to the provided MuxedAddressObject as a U64Val.",
                    "min_supported_protocol": 23
                },
                {
                    "export": "6",
                    "name": "get_address_executable",
                    "args": [
                        {
                            "name": "address",
                            "type": "AddressObject"
                        }
                    ],
                    "return": "Val",
                    "docs": "Returns the executable corresponding to the provided address. When the address does not exist on-chain, returns `Void` value. When it does exist, returns a value of `AddressExecutable` contract type. It is an enum with `Wasm` value and the corresponding Wasm hash for the Wasm contracts, `StellarAsset` value for Stellar Asset contract instances, and `Account` value for the 'classic' (G-) accounts.",
                    "min_supported_protocol": 23
                }
            ]
        },
        {
            "name": "test",
            "export": "t",
            "functions": [
                {
                    "export": "_",
                    "name": "dummy0",
                    "args": [],
                    "return": "Val",
                    "docs": "A dummy function taking 0 arguments and performs no-op. This function is for test purpose only, for measuring the roundtrip cost of invoking a host function, i.e. host->Vm->host."
                },
                {
                    "export": "0",
                    "name": "protocol_gated_dummy",
                    "args": [],
                    "return": "Val",
                    "docs": "A dummy function for testing the protocol gating. Takes 0 arguments and performs no-op. Essentially this function is always protocol-gated out since it has `min_supported_protocol == max_supported_protocol == 19`, thus having no effect on any protocol (Soroban starts at protocol 20). This is required for testing the scenario where ledger protocol version > host function max supported version, and the ledger protocol version must be <= the `env` version (which starts at 20, and is a compile-time, non-overridable constant).",
                    "min_supported_protocol": 19,
                    "max_supported_protocol": 19
                }                
            ]
        },
        {
            "name": "prng",
            "export": "p",
            "functions": [
                {
                    "export": "_",
                    "name": "prng_reseed",
                    "args": [
                        {
                            "name": "seed",
                            "type": "BytesObject"
                        }
                    ],
                    "return": "Void",
                    "docs": "Reseed the frame-local PRNG with a given BytesObject, which should be 32 bytes long."
                },
                {
                    "export": "0",
                    "name": "prng_bytes_new",
                    "args": [
                        {
                            "name": "length",
                            "type": "U32Val"
                        }
                    ],
                    "return": "BytesObject",
                    "docs": "Construct a new BytesObject of the given length filled with bytes drawn from the frame-local PRNG."
                },
                {
                    "export": "1",
                    "name": "prng_u64_in_inclusive_range",
                    "args": [
                        {
                            "name": "lo",
                            "type": "u64"
                        },
                        {
                            "name": "hi",
                            "type": "u64"
                        }
                    ],
                    "return": "u64",
                    "docs": "Return a u64 uniformly sampled from the inclusive range [lo,hi] by the frame-local PRNG."
                },
                {
                    "export": "2",
                    "name": "prng_vec_shuffle",
                    "args": [
                        {
                            "name": "vec",
                            "type": "VecObject"
                        }
                    ],
                    "return": "VecObject",
                    "docs": "Return a (Fisher-Yates) shuffled clone of a given vector, using the frame-local PRNG."
                }
            ]
        }
    ]
}